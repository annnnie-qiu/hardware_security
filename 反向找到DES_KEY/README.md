
# 🔓 DES 扫描链攻击实验

本项目是完成硬件安全中的Scan Chain Attack，通过攻击提供的 DES IP 核中的扫描链接口，成功 **恢复密钥（DES Key）**，并构造自动化攻击代码完成整个破解过程。

---

## 🧠 项目背景

在现代加密芯片设计中，**扫描链（Scan Chain）** 通常用于测试内部寄存器状态。然而，如果未妥善保护，这一接口可能会成为攻击者窃取敏感信息的“后门”。

本实验的目标是通过分析提供的 DES IP（包含自定义密钥和寄存器布局），结合扫描链输出数据，从中推理并恢复 DES 加密过程中的关键轮密钥，最终还原完整的 56-bit DES 密钥。

---

## 🗂️ 项目结构

```bash
des_scan_attack/
├── des_scan_attack.py      # 自动化扫描链攻击脚本
├── .bin            # DES IP 核（含密钥）
├── .csv            # 扫描链结构布局（需手动填写）
├── 如何找到scan chain的bits/
  ├── des_scan_attack.py      # 自动化扫描链攻击脚本
  ├── des_scan_attack.py      # 自动化扫描链攻击脚本
```

---

## 🛠️ 实验环境与运行方式

首先初始化 DES IP 并开始数据采集，通过 SPI 通信收集 **Scan-Out 数据**，供后续分析使用。（主要是为了得到scan chain的输出数据）

---

## 🔍 攻击流程详解：从 Scan Chain 到密钥恢复

为了从 DES IP 中恢复密钥，我们参考了下图中 DES 的高层结构：
![image](https://github.com/user-attachments/assets/d5f1fe27-b1b7-44be-81c3-5a94dad7c862)
![image](https://github.com/user-attachments/assets/4dcfbe99-8a15-4091-a619-18062f0829cf)



> 图 1：DES 加密结构（包括轮函数和密钥派生）

### 🔸 第一步：寄存器与扫描链映射

我们通过分析实验提供的 `.csv` 文件和 Scan-Out 数据，构造了扫描链中每一位与寄存器之间的映射关系，例如：

```python
scan_chain_map = {
  72: "l[16]", 73: "r[19]", ..., 135: "r[5]"
}
```

这样，我们可以从扫描链输出中解析出某一时钟周期下的完整 `L` 和 `R` 状态：

```python
left_scan_indices = [...]
right_scan_indices = [...]
```

---

### 🔸 第二步：理解时序，获取每轮中间状态

根据 DES 的结构，我们得出以下时序逻辑：

| 时钟周期 | 状态     | 寄存器含义             |
|----------|----------|------------------------|
| CLK 1    | 加密前   | `Input → IP → (L0, R0)` |
| CLK 2    | 1轮后    | `L1 = R0`，`R1 = L0 ⊕ F(R0, K1)` |
| CLK 3    | 2轮后    | `L2 = R1`，`R2 = L1 ⊕ F(R1, K2)` |

通过对 **连续时钟周期下的 Scan-Out 数据进行对比**，我们能够推导出：

- `L0`, `R0` 是初始轮的输入状态
- `L1`, `R1` 是第一轮后的状态
- 利用 `R1 = L0 ⊕ F(R0, K1)` 的公式，我们可推得：

```python
F_result = xor_bits(L0, R1)
```

---

### 🔸 第三步：逆向轮函数 F，恢复 K1

我们接着利用 DES 的轮函数结构：

```
K1(48 bit) ⊕ E(R0) —> 输入S盒 —> P置换后为 F(R0, K1)
```

因此，已知：
- `R0`
- `F(R0, K1)`（从 R1 和 L0 推出）
- E-box、S-box、P 表

我们可以暴力枚举每一个可能的 6-bit S-box 输入，通过反向映射找出对应的 `K1` 比特段，从而拼出完整的 `K1`（共 48bit）。

---

### 🔸 第四步：逆向 PC2 和密钥调度，恢复原始密钥

得到轮密钥 `K1` 后，我们再逆向 DES 密钥调度流程：

```
原始 56-bit 密钥 —(PC1)—> C0, D0 —(左移)—> C1, D1 —(PC2)—> K1
```

此时我们可以：

1. **尝试逆推出**：哪些 C1, D1（左移后的密钥块）经过 PC2 会生成我们观察到的 `K1`。
2. 但由于 PC2 是压缩映射，仅靠 `K1` 逆推 C1, D1 存在多解。

---

#### ✅ 更进一步：结合第二轮密钥 K2 精准恢复

我们继续从 Scan Chain 获取 `K2`：

```
C1, D1 —(左移1次)—> C2, D2 —(PC2)—> K2
```

借助 K1 和 K2，我们可以穷举候选 C1, D1，使得：

- `PC2(C1, D1) == K1`
- `PC2(左移(C1, D1)) == K2`

只有一对正确的 C1, D1 会同时满足这两个条件，由此唯一确定 C0, D0，还原出原始的 **56-bit 密钥**。

---

#### 🧩 插入奇偶校验位，恢复完整 64-bit 密钥

DES 密钥总长为 64 bit，其中每 8bit 的最后一位为奇偶校验位：

```python
def insert_parity_bits(bits_56):
    bits_64 = ""
    for i in range(0, 56, 7):
        chunk = bits_56[i:i+7]
        parity = '1' if chunk.count('1') % 2 == 0 else '0'
        bits_64 += chunk + parity
    return bits_64
```

因此，我们**无需暴力猜测剩余 8bit**，可通过奇偶规则自动补全。

---

## ✅ 最终成果

- 🧠 利用扫描链恢复多轮寄存器状态
- 🔁 利用 DES 的结构公式（如 `R1 = L0 ⊕ F(R0, K1)`）恢复轮函数输出
- 🧩 基于 K1/K2 的双轮关系，精准恢复原始 56-bit 密钥
- 🔓 使用奇偶校验恢复完整 64-bit DES 密钥

攻击过程**无需暴力破解完整密钥**，完全通过硬件可观察状态与算法结构结合完成！

---

## 📎 致谢

本项目基于课程提供的实验框架构建，感谢课程教学团队设计了极具挑战性的实验任务！

